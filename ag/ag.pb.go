// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ag.proto

package ag

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Group_GroupStatus int32

const (
	Group_Pending  Group_GroupStatus = 0
	Group_Rejected Group_GroupStatus = 1
	Group_Approved Group_GroupStatus = 2
	Group_Deleted  Group_GroupStatus = 3
)

var Group_GroupStatus_name = map[int32]string{
	0: "Pending",
	1: "Rejected",
	2: "Approved",
	3: "Deleted",
}

var Group_GroupStatus_value = map[string]int32{
	"Pending":  0,
	"Rejected": 1,
	"Approved": 2,
	"Deleted":  3,
}

func (x Group_GroupStatus) String() string {
	return proto.EnumName(Group_GroupStatus_name, int32(x))
}

func (Group_GroupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{3, 0}
}

type Enrollment_UserStatus int32

const (
	Enrollment_Pending  Enrollment_UserStatus = 0
	Enrollment_Rejected Enrollment_UserStatus = 1
	Enrollment_Student  Enrollment_UserStatus = 2
	Enrollment_Teacher  Enrollment_UserStatus = 3
)

var Enrollment_UserStatus_name = map[int32]string{
	0: "Pending",
	1: "Rejected",
	2: "Student",
	3: "Teacher",
}

var Enrollment_UserStatus_value = map[string]int32{
	"Pending":  0,
	"Rejected": 1,
	"Student":  2,
	"Teacher":  3,
}

func (x Enrollment_UserStatus) String() string {
	return proto.EnumName(Enrollment_UserStatus_name, int32(x))
}

func (Enrollment_UserStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{7, 0}
}

type Repository_RepoType int32

const (
	Repository_User       Repository_RepoType = 0
	Repository_Assignment Repository_RepoType = 1
	Repository_Tests      Repository_RepoType = 2
	Repository_Solution   Repository_RepoType = 3
	Repository_CourseInfo Repository_RepoType = 4
)

var Repository_RepoType_name = map[int32]string{
	0: "User",
	1: "Assignment",
	2: "Tests",
	3: "Solution",
	4: "CourseInfo",
}

var Repository_RepoType_value = map[string]int32{
	"User":       0,
	"Assignment": 1,
	"Tests":      2,
	"Solution":   3,
	"CourseInfo": 4,
}

func (x Repository_RepoType) String() string {
	return proto.EnumName(Repository_RepoType_name, int32(x))
}

func (Repository_RepoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{13, 0}
}

type User struct {
	ID               uint64            `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	IsAdmin          bool              `protobuf:"varint,2,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
	Name             string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Student_ID       string            `protobuf:"bytes,4,opt,name=student_ID,json=studentID,proto3" json:"student_ID,omitempty"`
	Email            string            `protobuf:"bytes,5,opt,name=email,proto3" json:"email,omitempty"`
	Avatar_URL       string            `protobuf:"bytes,6,opt,name=avatar_URL,json=avatarURL,proto3" json:"avatar_URL,omitempty"`
	RemoteIdentities []*RemoteIdentity `protobuf:"bytes,7,rep,name=remote_identities,json=remoteIdentities,proto3" json:"remote_identities,omitempty"`
	Enrollments      []*Enrollment     `protobuf:"bytes,8,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{0}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *User) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetStudent_ID() string {
	if m != nil {
		return m.Student_ID
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetAvatar_URL() string {
	if m != nil {
		return m.Avatar_URL
	}
	return ""
}

func (m *User) GetRemoteIdentities() []*RemoteIdentity {
	if m != nil {
		return m.RemoteIdentities
	}
	return nil
}

func (m *User) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Users struct {
	Users []*User `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
}

func (m *Users) Reset()         { *m = Users{} }
func (m *Users) String() string { return proto.CompactTextString(m) }
func (*Users) ProtoMessage()    {}
func (*Users) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{1}
}
func (m *Users) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Users) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Users.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Users) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Users.Merge(m, src)
}
func (m *Users) XXX_Size() int {
	return m.Size()
}
func (m *Users) XXX_DiscardUnknown() {
	xxx_messageInfo_Users.DiscardUnknown(m)
}

var xxx_messageInfo_Users proto.InternalMessageInfo

func (m *Users) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type RemoteIdentity struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Provider    string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty" gorm:"unique_index:uid_provider_remote_id"`
	Remote_ID   uint64 `protobuf:"varint,3,opt,name=remote_ID,json=remoteID,proto3" json:"remote_ID,omitempty" gorm:"unique_index:uid_provider_remote_id"`
	AccessToken string `protobuf:"bytes,4,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	User_ID     uint64 `protobuf:"varint,5,opt,name=user_ID,json=userID,proto3" json:"user_ID,omitempty"`
}

func (m *RemoteIdentity) Reset()         { *m = RemoteIdentity{} }
func (m *RemoteIdentity) String() string { return proto.CompactTextString(m) }
func (*RemoteIdentity) ProtoMessage()    {}
func (*RemoteIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{2}
}
func (m *RemoteIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteIdentity.Merge(m, src)
}
func (m *RemoteIdentity) XXX_Size() int {
	return m.Size()
}
func (m *RemoteIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteIdentity proto.InternalMessageInfo

func (m *RemoteIdentity) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RemoteIdentity) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *RemoteIdentity) GetRemote_ID() uint64 {
	if m != nil {
		return m.Remote_ID
	}
	return 0
}

func (m *RemoteIdentity) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *RemoteIdentity) GetUser_ID() uint64 {
	if m != nil {
		return m.User_ID
	}
	return 0
}

type Group struct {
	ID          uint64            `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name        string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" gorm:"unique_index:idx_unique_group_name"`
	Course_ID   uint64            `protobuf:"varint,3,opt,name=course_ID,json=courseID,proto3" json:"course_ID,omitempty" gorm:"unique_index:idx_unique_group_name"`
	Status      Group_GroupStatus `protobuf:"varint,4,opt,name=status,proto3,enum=Group_GroupStatus" json:"status,omitempty"`
	Users       []*User           `protobuf:"bytes,5,rep,name=users,proto3" json:"users,omitempty"`
	Enrollments []*Enrollment     `protobuf:"bytes,6,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{3}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Group) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Group) GetCourse_ID() uint64 {
	if m != nil {
		return m.Course_ID
	}
	return 0
}

func (m *Group) GetStatus() Group_GroupStatus {
	if m != nil {
		return m.Status
	}
	return Group_Pending
}

func (m *Group) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *Group) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Groups struct {
	Groups []*Group `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups,omitempty"`
}

func (m *Groups) Reset()         { *m = Groups{} }
func (m *Groups) String() string { return proto.CompactTextString(m) }
func (*Groups) ProtoMessage()    {}
func (*Groups) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{4}
}
func (m *Groups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Groups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Groups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Groups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Groups.Merge(m, src)
}
func (m *Groups) XXX_Size() int {
	return m.Size()
}
func (m *Groups) XXX_DiscardUnknown() {
	xxx_messageInfo_Groups.DiscardUnknown(m)
}

var xxx_messageInfo_Groups proto.InternalMessageInfo

func (m *Groups) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Course struct {
	ID               uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	CourseCreator_ID uint64                `protobuf:"varint,2,opt,name=course_creator_ID,json=courseCreatorID,proto3" json:"course_creator_ID,omitempty"`
	Name             string                `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Code             string                `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	Year             uint32                `protobuf:"varint,5,opt,name=year,proto3" json:"year,omitempty"`
	Tag              string                `protobuf:"bytes,6,opt,name=tag,proto3" json:"tag,omitempty"`
	Provider         string                `protobuf:"bytes,7,opt,name=provider,proto3" json:"provider,omitempty"`
	Directory_ID     uint64                `protobuf:"varint,8,opt,name=directory_ID,json=directoryID,proto3" json:"directory_ID,omitempty"`
	Enrolled         Enrollment_UserStatus `protobuf:"varint,9,opt,name=enrolled,proto3,enum=Enrollment_UserStatus" json:"enrolled,omitempty"`
	Enrollments      []*Enrollment         `protobuf:"bytes,10,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
	Assignments      []*Assignment         `protobuf:"bytes,12,rep,name=assignments,proto3" json:"assignments,omitempty"`
	Groups           []*Group              `protobuf:"bytes,13,rep,name=groups,proto3" json:"groups,omitempty"`
}

func (m *Course) Reset()         { *m = Course{} }
func (m *Course) String() string { return proto.CompactTextString(m) }
func (*Course) ProtoMessage()    {}
func (*Course) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{5}
}
func (m *Course) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Course) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Course.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Course) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Course.Merge(m, src)
}
func (m *Course) XXX_Size() int {
	return m.Size()
}
func (m *Course) XXX_DiscardUnknown() {
	xxx_messageInfo_Course.DiscardUnknown(m)
}

var xxx_messageInfo_Course proto.InternalMessageInfo

func (m *Course) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Course) GetCourseCreator_ID() uint64 {
	if m != nil {
		return m.CourseCreator_ID
	}
	return 0
}

func (m *Course) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Course) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Course) GetYear() uint32 {
	if m != nil {
		return m.Year
	}
	return 0
}

func (m *Course) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *Course) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Course) GetDirectory_ID() uint64 {
	if m != nil {
		return m.Directory_ID
	}
	return 0
}

func (m *Course) GetEnrolled() Enrollment_UserStatus {
	if m != nil {
		return m.Enrolled
	}
	return Enrollment_Pending
}

func (m *Course) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

func (m *Course) GetAssignments() []*Assignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

func (m *Course) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type Courses struct {
	Courses []*Course `protobuf:"bytes,1,rep,name=courses,proto3" json:"courses,omitempty"`
}

func (m *Courses) Reset()         { *m = Courses{} }
func (m *Courses) String() string { return proto.CompactTextString(m) }
func (*Courses) ProtoMessage()    {}
func (*Courses) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{6}
}
func (m *Courses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Courses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Courses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Courses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Courses.Merge(m, src)
}
func (m *Courses) XXX_Size() int {
	return m.Size()
}
func (m *Courses) XXX_DiscardUnknown() {
	xxx_messageInfo_Courses.DiscardUnknown(m)
}

var xxx_messageInfo_Courses proto.InternalMessageInfo

func (m *Courses) GetCourses() []*Course {
	if m != nil {
		return m.Courses
	}
	return nil
}

type Enrollment struct {
	ID        uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Course_ID uint64                `protobuf:"varint,2,opt,name=course_ID,json=courseID,proto3" json:"course_ID,omitempty" gorm:"unique_index:idx_unique_group_name"`
	User_ID   uint64                `protobuf:"varint,3,opt,name=user_ID,json=userID,proto3" json:"user_ID,omitempty" gorm:"unique_index:idx_unique_group_name"`
	Group_ID  uint64                `protobuf:"varint,4,opt,name=group_ID,json=groupID,proto3" json:"group_ID,omitempty"`
	User      *User                 `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty"`
	Course    *Course               `protobuf:"bytes,6,opt,name=course,proto3" json:"course,omitempty"`
	Group     *Group                `protobuf:"bytes,7,opt,name=group,proto3" json:"group,omitempty"`
	Status    Enrollment_UserStatus `protobuf:"varint,8,opt,name=status,proto3,enum=Enrollment_UserStatus" json:"status,omitempty"`
}

func (m *Enrollment) Reset()         { *m = Enrollment{} }
func (m *Enrollment) String() string { return proto.CompactTextString(m) }
func (*Enrollment) ProtoMessage()    {}
func (*Enrollment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{7}
}
func (m *Enrollment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Enrollment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Enrollment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Enrollment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Enrollment.Merge(m, src)
}
func (m *Enrollment) XXX_Size() int {
	return m.Size()
}
func (m *Enrollment) XXX_DiscardUnknown() {
	xxx_messageInfo_Enrollment.DiscardUnknown(m)
}

var xxx_messageInfo_Enrollment proto.InternalMessageInfo

func (m *Enrollment) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Enrollment) GetCourse_ID() uint64 {
	if m != nil {
		return m.Course_ID
	}
	return 0
}

func (m *Enrollment) GetUser_ID() uint64 {
	if m != nil {
		return m.User_ID
	}
	return 0
}

func (m *Enrollment) GetGroup_ID() uint64 {
	if m != nil {
		return m.Group_ID
	}
	return 0
}

func (m *Enrollment) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Enrollment) GetCourse() *Course {
	if m != nil {
		return m.Course
	}
	return nil
}

func (m *Enrollment) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *Enrollment) GetStatus() Enrollment_UserStatus {
	if m != nil {
		return m.Status
	}
	return Enrollment_Pending
}

type Enrollments struct {
	Enrollments []*Enrollment `protobuf:"bytes,1,rep,name=enrollments,proto3" json:"enrollments,omitempty"`
}

func (m *Enrollments) Reset()         { *m = Enrollments{} }
func (m *Enrollments) String() string { return proto.CompactTextString(m) }
func (*Enrollments) ProtoMessage()    {}
func (*Enrollments) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{8}
}
func (m *Enrollments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Enrollments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Enrollments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Enrollments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Enrollments.Merge(m, src)
}
func (m *Enrollments) XXX_Size() int {
	return m.Size()
}
func (m *Enrollments) XXX_DiscardUnknown() {
	xxx_messageInfo_Enrollments.DiscardUnknown(m)
}

var xxx_messageInfo_Enrollments proto.InternalMessageInfo

func (m *Enrollments) GetEnrollments() []*Enrollment {
	if m != nil {
		return m.Enrollments
	}
	return nil
}

type Assignment struct {
	ID          uint64           `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Course_ID   uint64           `protobuf:"varint,2,opt,name=course_ID,json=courseID,proto3" json:"course_ID,omitempty"`
	Name        string           `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Language    string           `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Deadline    *types.Timestamp `protobuf:"bytes,5,opt,name=deadline,proto3" json:"deadline,omitempty"`
	AutoApprove bool             `protobuf:"varint,6,opt,name=auto_approve,json=autoApprove,proto3" json:"auto_approve,omitempty"`
	Order       uint32           `protobuf:"varint,7,opt,name=order,proto3" json:"order,omitempty"`
	IsGroupLab  bool             `protobuf:"varint,8,opt,name=is_group_lab,json=isGroupLab,proto3" json:"is_group_lab,omitempty"`
	Submission  *Submission      `protobuf:"bytes,9,opt,name=submission,proto3" json:"submission,omitempty"`
}

func (m *Assignment) Reset()         { *m = Assignment{} }
func (m *Assignment) String() string { return proto.CompactTextString(m) }
func (*Assignment) ProtoMessage()    {}
func (*Assignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{9}
}
func (m *Assignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Assignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Assignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Assignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Assignment.Merge(m, src)
}
func (m *Assignment) XXX_Size() int {
	return m.Size()
}
func (m *Assignment) XXX_DiscardUnknown() {
	xxx_messageInfo_Assignment.DiscardUnknown(m)
}

var xxx_messageInfo_Assignment proto.InternalMessageInfo

func (m *Assignment) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Assignment) GetCourse_ID() uint64 {
	if m != nil {
		return m.Course_ID
	}
	return 0
}

func (m *Assignment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Assignment) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Assignment) GetDeadline() *types.Timestamp {
	if m != nil {
		return m.Deadline
	}
	return nil
}

func (m *Assignment) GetAutoApprove() bool {
	if m != nil {
		return m.AutoApprove
	}
	return false
}

func (m *Assignment) GetOrder() uint32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *Assignment) GetIsGroupLab() bool {
	if m != nil {
		return m.IsGroupLab
	}
	return false
}

func (m *Assignment) GetSubmission() *Submission {
	if m != nil {
		return m.Submission
	}
	return nil
}

type Assignments struct {
	Assignments []*Assignment `protobuf:"bytes,1,rep,name=assignments,proto3" json:"assignments,omitempty"`
}

func (m *Assignments) Reset()         { *m = Assignments{} }
func (m *Assignments) String() string { return proto.CompactTextString(m) }
func (*Assignments) ProtoMessage()    {}
func (*Assignments) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{10}
}
func (m *Assignments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Assignments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Assignments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Assignments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Assignments.Merge(m, src)
}
func (m *Assignments) XXX_Size() int {
	return m.Size()
}
func (m *Assignments) XXX_DiscardUnknown() {
	xxx_messageInfo_Assignments.DiscardUnknown(m)
}

var xxx_messageInfo_Assignments proto.InternalMessageInfo

func (m *Assignments) GetAssignments() []*Assignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

type Submission struct {
	ID            uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Assignment_ID uint64 `protobuf:"varint,2,opt,name=assignment_ID,json=assignmentID,proto3" json:"assignment_ID,omitempty"`
	User_ID       uint64 `protobuf:"varint,3,opt,name=user_ID,json=userID,proto3" json:"user_ID,omitempty"`
	Group_ID      uint64 `protobuf:"varint,4,opt,name=group_ID,json=groupID,proto3" json:"group_ID,omitempty"`
	Score         uint32 `protobuf:"varint,5,opt,name=score,proto3" json:"score,omitempty"`
	ScoreObjects  string `protobuf:"bytes,6,opt,name=score_objects,json=scoreObjects,proto3" json:"score_objects,omitempty"`
	BuildInfo     string `protobuf:"bytes,7,opt,name=build_info,json=buildInfo,proto3" json:"build_info,omitempty"`
	CommitHash    string `protobuf:"bytes,8,opt,name=commit_hash,json=commitHash,proto3" json:"commit_hash,omitempty"`
	Approved      bool   `protobuf:"varint,9,opt,name=approved,proto3" json:"approved,omitempty"`
}

func (m *Submission) Reset()         { *m = Submission{} }
func (m *Submission) String() string { return proto.CompactTextString(m) }
func (*Submission) ProtoMessage()    {}
func (*Submission) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{11}
}
func (m *Submission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Submission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Submission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Submission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Submission.Merge(m, src)
}
func (m *Submission) XXX_Size() int {
	return m.Size()
}
func (m *Submission) XXX_DiscardUnknown() {
	xxx_messageInfo_Submission.DiscardUnknown(m)
}

var xxx_messageInfo_Submission proto.InternalMessageInfo

func (m *Submission) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Submission) GetAssignment_ID() uint64 {
	if m != nil {
		return m.Assignment_ID
	}
	return 0
}

func (m *Submission) GetUser_ID() uint64 {
	if m != nil {
		return m.User_ID
	}
	return 0
}

func (m *Submission) GetGroup_ID() uint64 {
	if m != nil {
		return m.Group_ID
	}
	return 0
}

func (m *Submission) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Submission) GetScoreObjects() string {
	if m != nil {
		return m.ScoreObjects
	}
	return ""
}

func (m *Submission) GetBuildInfo() string {
	if m != nil {
		return m.BuildInfo
	}
	return ""
}

func (m *Submission) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Submission) GetApproved() bool {
	if m != nil {
		return m.Approved
	}
	return false
}

type Submissions struct {
	Submissions []*Submission `protobuf:"bytes,1,rep,name=submissions,proto3" json:"submissions,omitempty"`
}

func (m *Submissions) Reset()         { *m = Submissions{} }
func (m *Submissions) String() string { return proto.CompactTextString(m) }
func (*Submissions) ProtoMessage()    {}
func (*Submissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{12}
}
func (m *Submissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Submissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Submissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Submissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Submissions.Merge(m, src)
}
func (m *Submissions) XXX_Size() int {
	return m.Size()
}
func (m *Submissions) XXX_DiscardUnknown() {
	xxx_messageInfo_Submissions.DiscardUnknown(m)
}

var xxx_messageInfo_Submissions proto.InternalMessageInfo

func (m *Submissions) GetSubmissions() []*Submission {
	if m != nil {
		return m.Submissions
	}
	return nil
}

type Repository struct {
	ID            uint64              `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Directory_ID  uint64              `protobuf:"varint,2,opt,name=directory_ID,json=directoryID,proto3" json:"directory_ID,omitempty"`
	Repository_ID uint64              `protobuf:"varint,3,opt,name=repository_ID,json=repositoryID,proto3" json:"repository_ID,omitempty"`
	User_ID       uint64              `protobuf:"varint,4,opt,name=user_ID,json=userID,proto3" json:"user_ID,omitempty"`
	Group_ID      uint64              `protobuf:"varint,5,opt,name=group_ID,json=groupID,proto3" json:"group_ID,omitempty"`
	HTML_URL      string              `protobuf:"bytes,6,opt,name=HTML_URL,json=HTMLURL,proto3" json:"HTML_URL,omitempty"`
	RepoType      Repository_RepoType `protobuf:"varint,7,opt,name=repo_type,json=repoType,proto3,enum=Repository_RepoType" json:"repo_type,omitempty"`
}

func (m *Repository) Reset()         { *m = Repository{} }
func (m *Repository) String() string { return proto.CompactTextString(m) }
func (*Repository) ProtoMessage()    {}
func (*Repository) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{13}
}
func (m *Repository) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repository) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repository.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repository) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repository.Merge(m, src)
}
func (m *Repository) XXX_Size() int {
	return m.Size()
}
func (m *Repository) XXX_DiscardUnknown() {
	xxx_messageInfo_Repository.DiscardUnknown(m)
}

var xxx_messageInfo_Repository proto.InternalMessageInfo

func (m *Repository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Repository) GetDirectory_ID() uint64 {
	if m != nil {
		return m.Directory_ID
	}
	return 0
}

func (m *Repository) GetRepository_ID() uint64 {
	if m != nil {
		return m.Repository_ID
	}
	return 0
}

func (m *Repository) GetUser_ID() uint64 {
	if m != nil {
		return m.User_ID
	}
	return 0
}

func (m *Repository) GetGroup_ID() uint64 {
	if m != nil {
		return m.Group_ID
	}
	return 0
}

func (m *Repository) GetHTML_URL() string {
	if m != nil {
		return m.HTML_URL
	}
	return ""
}

func (m *Repository) GetRepoType() Repository_RepoType {
	if m != nil {
		return m.RepoType
	}
	return Repository_User
}

type Repositories struct {
	Repositories []*Repository `protobuf:"bytes,1,rep,name=repositories,proto3" json:"repositories,omitempty"`
}

func (m *Repositories) Reset()         { *m = Repositories{} }
func (m *Repositories) String() string { return proto.CompactTextString(m) }
func (*Repositories) ProtoMessage()    {}
func (*Repositories) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{14}
}
func (m *Repositories) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repositories) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repositories.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repositories) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repositories.Merge(m, src)
}
func (m *Repositories) XXX_Size() int {
	return m.Size()
}
func (m *Repositories) XXX_DiscardUnknown() {
	xxx_messageInfo_Repositories.DiscardUnknown(m)
}

var xxx_messageInfo_Repositories proto.InternalMessageInfo

func (m *Repositories) GetRepositories() []*Repository {
	if m != nil {
		return m.Repositories
	}
	return nil
}

type Directory struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Path   string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Avatar string `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *Directory) Reset()         { *m = Directory{} }
func (m *Directory) String() string { return proto.CompactTextString(m) }
func (*Directory) ProtoMessage()    {}
func (*Directory) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{15}
}
func (m *Directory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Directory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Directory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Directory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Directory.Merge(m, src)
}
func (m *Directory) XXX_Size() int {
	return m.Size()
}
func (m *Directory) XXX_DiscardUnknown() {
	xxx_messageInfo_Directory.DiscardUnknown(m)
}

var xxx_messageInfo_Directory proto.InternalMessageInfo

func (m *Directory) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Directory) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Directory) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

type Directories struct {
	Directories []*Directory `protobuf:"bytes,1,rep,name=directories,proto3" json:"directories,omitempty"`
}

func (m *Directories) Reset()         { *m = Directories{} }
func (m *Directories) String() string { return proto.CompactTextString(m) }
func (*Directories) ProtoMessage()    {}
func (*Directories) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{16}
}
func (m *Directories) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Directories) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Directories.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Directories) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Directories.Merge(m, src)
}
func (m *Directories) XXX_Size() int {
	return m.Size()
}
func (m *Directories) XXX_DiscardUnknown() {
	xxx_messageInfo_Directories.DiscardUnknown(m)
}

var xxx_messageInfo_Directories proto.InternalMessageInfo

func (m *Directories) GetDirectories() []*Directory {
	if m != nil {
		return m.Directories
	}
	return nil
}

type RecordRequest struct {
	ID            uint64                  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Statuses      []Enrollment_UserStatus `protobuf:"varint,2,rep,packed,name=statuses,proto3,enum=Enrollment_UserStatus" json:"statuses,omitempty"`
	GroupStatuses []Group_GroupStatus     `protobuf:"varint,3,rep,packed,name=group_statuses,json=groupStatuses,proto3,enum=Group_GroupStatus" json:"group_statuses,omitempty"`
}

func (m *RecordRequest) Reset()         { *m = RecordRequest{} }
func (m *RecordRequest) String() string { return proto.CompactTextString(m) }
func (*RecordRequest) ProtoMessage()    {}
func (*RecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{17}
}
func (m *RecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordRequest.Merge(m, src)
}
func (m *RecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecordRequest proto.InternalMessageInfo

func (m *RecordRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RecordRequest) GetStatuses() []Enrollment_UserStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func (m *RecordRequest) GetGroupStatuses() []Group_GroupStatus {
	if m != nil {
		return m.GroupStatuses
	}
	return nil
}

// fields can be empty, do not use fields for user validation, use context
// can be used in submission, enrollment and group requests, also in requests with multiple IDs
type ActionRequest struct {
	ID          uint64                `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	User_ID     uint64                `protobuf:"varint,2,opt,name=user_ID,json=userID,proto3" json:"user_ID,omitempty"`
	Group_ID    uint64                `protobuf:"varint,3,opt,name=group_ID,json=groupID,proto3" json:"group_ID,omitempty"`
	Course_ID   uint64                `protobuf:"varint,4,opt,name=course_ID,json=courseID,proto3" json:"course_ID,omitempty"`
	Status      Enrollment_UserStatus `protobuf:"varint,5,opt,name=status,proto3,enum=Enrollment_UserStatus" json:"status,omitempty"`
	GroupStatus Group_GroupStatus     `protobuf:"varint,6,opt,name=group_status,json=groupStatus,proto3,enum=Group_GroupStatus" json:"group_status,omitempty"`
}

func (m *ActionRequest) Reset()         { *m = ActionRequest{} }
func (m *ActionRequest) String() string { return proto.CompactTextString(m) }
func (*ActionRequest) ProtoMessage()    {}
func (*ActionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{18}
}
func (m *ActionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRequest.Merge(m, src)
}
func (m *ActionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ActionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRequest proto.InternalMessageInfo

func (m *ActionRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActionRequest) GetUser_ID() uint64 {
	if m != nil {
		return m.User_ID
	}
	return 0
}

func (m *ActionRequest) GetGroup_ID() uint64 {
	if m != nil {
		return m.Group_ID
	}
	return 0
}

func (m *ActionRequest) GetCourse_ID() uint64 {
	if m != nil {
		return m.Course_ID
	}
	return 0
}

func (m *ActionRequest) GetStatus() Enrollment_UserStatus {
	if m != nil {
		return m.Status
	}
	return Enrollment_Pending
}

func (m *ActionRequest) GetGroupStatus() Group_GroupStatus {
	if m != nil {
		return m.GroupStatus
	}
	return Group_Pending
}

type DirectoryRequest struct {
	Provider  string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	Course_ID uint64 `protobuf:"varint,2,opt,name=course_ID,json=courseID,proto3" json:"course_ID,omitempty"`
}

func (m *DirectoryRequest) Reset()         { *m = DirectoryRequest{} }
func (m *DirectoryRequest) String() string { return proto.CompactTextString(m) }
func (*DirectoryRequest) ProtoMessage()    {}
func (*DirectoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{19}
}
func (m *DirectoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectoryRequest.Merge(m, src)
}
func (m *DirectoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *DirectoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DirectoryRequest proto.InternalMessageInfo

func (m *DirectoryRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *DirectoryRequest) GetCourse_ID() uint64 {
	if m != nil {
		return m.Course_ID
	}
	return 0
}

type RepositoryRequest struct {
	ID            uint64              `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Type          Repository_RepoType `protobuf:"varint,2,opt,name=type,proto3,enum=Repository_RepoType" json:"type,omitempty"`
	Directory_ID  uint64              `protobuf:"varint,3,opt,name=directory_ID,json=directoryID,proto3" json:"directory_ID,omitempty"`
	Repository_ID uint64              `protobuf:"varint,4,opt,name=repository_ID,json=repositoryID,proto3" json:"repository_ID,omitempty"`
	User_ID       uint64              `protobuf:"varint,5,opt,name=user_ID,json=userID,proto3" json:"user_ID,omitempty"`
	Course_ID     uint64              `protobuf:"varint,6,opt,name=course_ID,json=courseID,proto3" json:"course_ID,omitempty"`
}

func (m *RepositoryRequest) Reset()         { *m = RepositoryRequest{} }
func (m *RepositoryRequest) String() string { return proto.CompactTextString(m) }
func (*RepositoryRequest) ProtoMessage()    {}
func (*RepositoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{20}
}
func (m *RepositoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepositoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepositoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepositoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepositoryRequest.Merge(m, src)
}
func (m *RepositoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *RepositoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RepositoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RepositoryRequest proto.InternalMessageInfo

func (m *RepositoryRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RepositoryRequest) GetType() Repository_RepoType {
	if m != nil {
		return m.Type
	}
	return Repository_User
}

func (m *RepositoryRequest) GetDirectory_ID() uint64 {
	if m != nil {
		return m.Directory_ID
	}
	return 0
}

func (m *RepositoryRequest) GetRepository_ID() uint64 {
	if m != nil {
		return m.Repository_ID
	}
	return 0
}

func (m *RepositoryRequest) GetUser_ID() uint64 {
	if m != nil {
		return m.User_ID
	}
	return 0
}

func (m *RepositoryRequest) GetCourse_ID() uint64 {
	if m != nil {
		return m.Course_ID
	}
	return 0
}

type Providers struct {
	Providers []string `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
}

func (m *Providers) Reset()         { *m = Providers{} }
func (m *Providers) String() string { return proto.CompactTextString(m) }
func (*Providers) ProtoMessage()    {}
func (*Providers) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{21}
}
func (m *Providers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Providers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Providers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Providers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Providers.Merge(m, src)
}
func (m *Providers) XXX_Size() int {
	return m.Size()
}
func (m *Providers) XXX_DiscardUnknown() {
	xxx_messageInfo_Providers.DiscardUnknown(m)
}

var xxx_messageInfo_Providers proto.InternalMessageInfo

func (m *Providers) GetProviders() []string {
	if m != nil {
		return m.Providers
	}
	return nil
}

type URLResponse struct {
	URL string `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
}

func (m *URLResponse) Reset()         { *m = URLResponse{} }
func (m *URLResponse) String() string { return proto.CompactTextString(m) }
func (*URLResponse) ProtoMessage()    {}
func (*URLResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{22}
}
func (m *URLResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_URLResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *URLResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLResponse.Merge(m, src)
}
func (m *URLResponse) XXX_Size() int {
	return m.Size()
}
func (m *URLResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_URLResponse.DiscardUnknown(m)
}

var xxx_messageInfo_URLResponse proto.InternalMessageInfo

func (m *URLResponse) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type Void struct {
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a984e8f57169aa1, []int{23}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return m.Size()
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("Group_GroupStatus", Group_GroupStatus_name, Group_GroupStatus_value)
	proto.RegisterEnum("Enrollment_UserStatus", Enrollment_UserStatus_name, Enrollment_UserStatus_value)
	proto.RegisterEnum("Repository_RepoType", Repository_RepoType_name, Repository_RepoType_value)
	proto.RegisterType((*User)(nil), "User")
	proto.RegisterType((*Users)(nil), "Users")
	proto.RegisterType((*RemoteIdentity)(nil), "RemoteIdentity")
	proto.RegisterType((*Group)(nil), "Group")
	proto.RegisterType((*Groups)(nil), "Groups")
	proto.RegisterType((*Course)(nil), "Course")
	proto.RegisterType((*Courses)(nil), "Courses")
	proto.RegisterType((*Enrollment)(nil), "Enrollment")
	proto.RegisterType((*Enrollments)(nil), "Enrollments")
	proto.RegisterType((*Assignment)(nil), "Assignment")
	proto.RegisterType((*Assignments)(nil), "Assignments")
	proto.RegisterType((*Submission)(nil), "Submission")
	proto.RegisterType((*Submissions)(nil), "Submissions")
	proto.RegisterType((*Repository)(nil), "Repository")
	proto.RegisterType((*Repositories)(nil), "Repositories")
	proto.RegisterType((*Directory)(nil), "Directory")
	proto.RegisterType((*Directories)(nil), "Directories")
	proto.RegisterType((*RecordRequest)(nil), "RecordRequest")
	proto.RegisterType((*ActionRequest)(nil), "ActionRequest")
	proto.RegisterType((*DirectoryRequest)(nil), "DirectoryRequest")
	proto.RegisterType((*RepositoryRequest)(nil), "RepositoryRequest")
	proto.RegisterType((*Providers)(nil), "Providers")
	proto.RegisterType((*URLResponse)(nil), "URLResponse")
	proto.RegisterType((*Void)(nil), "Void")
}

func init() { proto.RegisterFile("ag.proto", fileDescriptor_7a984e8f57169aa1) }

var fileDescriptor_7a984e8f57169aa1 = []byte{
	// 1853 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4f, 0x8f, 0xdb, 0xc6,
	0x15, 0x17, 0xf5, 0x97, 0x7a, 0xa4, 0x36, 0xda, 0xa9, 0xe1, 0x28, 0x6b, 0x57, 0xbb, 0xa6, 0x83,
	0x62, 0x63, 0xc7, 0x74, 0xbb, 0x41, 0x8c, 0x26, 0x0d, 0x50, 0xc8, 0x56, 0xba, 0x51, 0xb2, 0x41,
	0x83, 0xd9, 0xdd, 0xf6, 0x28, 0x70, 0xc5, 0x59, 0x2d, 0x5b, 0x89, 0xa3, 0x70, 0x48, 0x23, 0x7b,
	0x2e, 0xd0, 0x53, 0x51, 0xf4, 0xd8, 0x43, 0xbf, 0x40, 0x3f, 0x40, 0xbf, 0x43, 0x81, 0x5e, 0x72,
	0x6b, 0x4f, 0x41, 0x61, 0x7f, 0x83, 0x00, 0xbd, 0x17, 0xf3, 0x87, 0x9c, 0x11, 0xa9, 0x95, 0xed,
	0xf6, 0x22, 0xcc, 0xbc, 0x7f, 0x7c, 0xef, 0xf7, 0xfe, 0xcc, 0x13, 0xd8, 0xc1, 0xdc, 0x5f, 0x25,
	0x34, 0xa5, 0x7b, 0x8f, 0xe6, 0x51, 0x7a, 0x95, 0x5d, 0xf8, 0x33, 0xba, 0x7c, 0x3c, 0xa7, 0x73,
	0xfa, 0x58, 0x90, 0x2f, 0xb2, 0x4b, 0x71, 0x13, 0x17, 0x71, 0x52, 0xe2, 0xfb, 0x73, 0x4a, 0xe7,
	0x0b, 0xa2, 0xa5, 0xd2, 0x68, 0x49, 0x58, 0x1a, 0x2c, 0x57, 0x52, 0xc0, 0xfb, 0x7d, 0x1d, 0x9a,
	0xe7, 0x8c, 0x24, 0x68, 0x07, 0xea, 0x93, 0xf1, 0xc0, 0x3a, 0xb0, 0x0e, 0x9b, 0xb8, 0x3e, 0x19,
	0xa3, 0x77, 0xc0, 0x8e, 0xd8, 0x34, 0x08, 0x97, 0x51, 0x3c, 0xa8, 0x1f, 0x58, 0x87, 0x36, 0xee,
	0x44, 0x6c, 0xc4, 0xaf, 0x08, 0x41, 0x33, 0x0e, 0x96, 0x64, 0xd0, 0x38, 0xb0, 0x0e, 0xbb, 0x58,
	0x9c, 0xd1, 0x0f, 0x01, 0x58, 0x9a, 0x85, 0x24, 0x4e, 0xa7, 0x93, 0xf1, 0xa0, 0x29, 0x38, 0x5d,
	0x45, 0x99, 0x8c, 0xd1, 0x2d, 0x68, 0x91, 0x65, 0x10, 0x2d, 0x06, 0x2d, 0xc1, 0x91, 0x17, 0xae,
	0x14, 0x3c, 0x0f, 0xd2, 0x20, 0x99, 0x9e, 0xe3, 0x93, 0x41, 0x5b, 0x2a, 0x49, 0xca, 0x39, 0x3e,
	0x41, 0x9f, 0xc0, 0x6e, 0x42, 0x96, 0x34, 0x25, 0xd3, 0x88, 0x9b, 0x89, 0xd2, 0x88, 0xb0, 0x41,
	0xe7, 0xa0, 0x71, 0xe8, 0x1c, 0xbd, 0xe5, 0x63, 0xc1, 0x99, 0x48, 0xc6, 0x35, 0xee, 0x27, 0xe6,
	0x3d, 0x22, 0x0c, 0x3d, 0x02, 0x87, 0xc4, 0x09, 0x5d, 0x2c, 0x96, 0x24, 0x4e, 0xd9, 0xc0, 0x16,
	0x7a, 0x8e, 0xff, 0x69, 0x41, 0xc3, 0x26, 0xdf, 0x7b, 0x17, 0x5a, 0x1c, 0x07, 0x86, 0xee, 0x40,
	0x2b, 0xe3, 0x87, 0x81, 0x25, 0x34, 0x5a, 0x3e, 0x27, 0x63, 0x49, 0xf3, 0xfe, 0x63, 0xc1, 0xce,
	0xfa, 0x97, 0x2b, 0xc0, 0x7d, 0x0e, 0xf6, 0x2a, 0xa1, 0xcf, 0xa3, 0x90, 0x24, 0x02, 0xb8, 0xee,
	0x53, 0xff, 0xfb, 0xef, 0xf6, 0x1f, 0xcc, 0x69, 0xb2, 0xfc, 0xd8, 0xcb, 0xe2, 0xe8, 0xeb, 0x8c,
	0x4c, 0xa3, 0x38, 0x24, 0xdf, 0x7c, 0x9c, 0x45, 0xe1, 0x34, 0x17, 0x9d, 0x16, 0x91, 0x7a, 0xb8,
	0xd0, 0x47, 0x5f, 0x40, 0x57, 0xd1, 0x27, 0x63, 0x01, 0x77, 0xf3, 0xcd, 0x8d, 0x29, 0x60, 0xc6,
	0xe8, 0x1e, 0xb8, 0xc1, 0x6c, 0x46, 0x18, 0x9b, 0xa6, 0xf4, 0xb7, 0x24, 0x56, 0x49, 0x72, 0x24,
	0xed, 0x8c, 0x93, 0xd0, 0xdb, 0xd0, 0xe1, 0x71, 0xf2, 0xaf, 0xb5, 0x44, 0x40, 0x6d, 0x7e, 0x9d,
	0x8c, 0xbd, 0x97, 0x75, 0x68, 0x1d, 0x27, 0x34, 0x5b, 0x55, 0xc2, 0x1d, 0xa9, 0x62, 0x90, 0xa1,
	0x3e, 0xfa, 0xfe, 0xbb, 0xfd, 0xf7, 0x36, 0x78, 0x17, 0x85, 0xdf, 0x4c, 0x15, 0x61, 0xce, 0xcd,
	0x4c, 0xb9, 0x8e, 0xa7, 0x6a, 0xe7, 0x73, 0xe8, 0xce, 0x68, 0x96, 0x30, 0x23, 0xca, 0x37, 0xb4,
	0x63, 0x4b, 0xfd, 0xc9, 0x18, 0x3d, 0x80, 0x36, 0x4b, 0x83, 0x34, 0x63, 0x22, 0xbc, 0x9d, 0x23,
	0xe4, 0x0b, 0xb7, 0xe5, 0xef, 0xa9, 0xe0, 0x60, 0x25, 0xa1, 0x33, 0xdd, 0xaa, 0x66, 0xba, 0x5c,
	0x3e, 0xed, 0x57, 0x94, 0xcf, 0x33, 0x70, 0x8c, 0x4f, 0x20, 0x07, 0x3a, 0x5f, 0x91, 0x38, 0x8c,
	0xe2, 0x79, 0xbf, 0x86, 0x5c, 0xb0, 0x31, 0xf9, 0x0d, 0x99, 0xa5, 0x24, 0xec, 0x5b, 0xfc, 0x36,
	0x5a, 0xf1, 0x4c, 0x91, 0xb0, 0x5f, 0xe7, 0x82, 0x63, 0xb2, 0x20, 0x9c, 0xd5, 0xf0, 0x0e, 0xa1,
	0x2d, 0x8c, 0x30, 0x34, 0x84, 0xb6, 0x88, 0x2f, 0xaf, 0xc2, 0xb6, 0x0c, 0x00, 0x2b, 0xaa, 0xf7,
	0xbb, 0x06, 0xb4, 0x9f, 0x89, 0x98, 0x2b, 0x09, 0x79, 0x00, 0xbb, 0x0a, 0xcd, 0x59, 0x42, 0x82,
	0x94, 0x8a, 0x6c, 0xd6, 0x05, 0xfb, 0x2d, 0xc9, 0x78, 0x26, 0xe9, 0x93, 0xf1, 0xc6, 0x4e, 0x46,
	0xd0, 0x9c, 0xd1, 0x90, 0xa8, 0xf2, 0x10, 0x67, 0x4e, 0xbb, 0x26, 0x41, 0x22, 0x8a, 0xa2, 0x87,
	0xc5, 0x19, 0xf5, 0xa1, 0x91, 0x06, 0x73, 0xd5, 0xb5, 0xfc, 0x88, 0xf6, 0x8c, 0xca, 0xef, 0x08,
	0xb2, 0xae, 0xe4, 0x7b, 0xe0, 0x86, 0x51, 0x42, 0x66, 0x29, 0x4d, 0xae, 0xb9, 0x43, 0xb6, 0x70,
	0xc8, 0x29, 0x68, 0x93, 0x31, 0x3a, 0x02, 0x5b, 0x22, 0x4a, 0xc2, 0x41, 0x57, 0x24, 0xef, 0xb6,
	0x01, 0xb7, 0x48, 0x8e, 0x4a, 0x60, 0x21, 0x57, 0xce, 0x12, 0x6c, 0xcf, 0x12, 0x17, 0x0f, 0x18,
	0x8b, 0xe6, 0xb1, 0x14, 0x77, 0x95, 0xf8, 0xa8, 0xa0, 0x61, 0x93, 0x6f, 0x64, 0xa1, 0xb7, 0x31,
	0x0b, 0xef, 0x43, 0x47, 0x26, 0x81, 0xa1, 0x7b, 0xd0, 0x91, 0xe0, 0xe6, 0x19, 0xeb, 0xf8, 0x92,
	0x85, 0x73, 0xba, 0xf7, 0xe7, 0x06, 0x80, 0x76, 0x6c, 0xc3, 0xdc, 0x30, 0xba, 0xa0, 0xfe, 0xff,
	0x75, 0xc1, 0x2f, 0x74, 0x1f, 0xff, 0x4f, 0xfd, 0xa4, 0xda, 0x9e, 0x3f, 0x02, 0x92, 0xac, 0x66,
	0x7a, 0x13, 0x77, 0xc4, 0x5d, 0xb0, 0x9a, 0x5c, 0x48, 0x94, 0x44, 0xd1, 0x3b, 0x82, 0x84, 0xf6,
	0xa1, 0x2d, 0x3d, 0x11, 0xc5, 0x61, 0x40, 0xa1, 0xc8, 0xe8, 0x2e, 0xb4, 0x84, 0x19, 0x51, 0x25,
	0x1a, 0x56, 0x49, 0x44, 0x7e, 0xd1, 0xc2, 0xf6, 0xd6, 0x2a, 0x50, 0x52, 0xde, 0x08, 0x40, 0x53,
	0xb7, 0x75, 0x9e, 0x03, 0x9d, 0x53, 0xf9, 0x22, 0xc9, 0xc6, 0x3b, 0x23, 0xc1, 0xec, 0x8a, 0x24,
	0xfd, 0x86, 0xf7, 0x09, 0x38, 0x9f, 0xae, 0x97, 0x89, 0x59, 0x55, 0xd6, 0x2b, 0x7a, 0xff, 0xaf,
	0x75, 0x00, 0x5d, 0x42, 0x95, 0xc4, 0xde, 0xa9, 0x24, 0xd6, 0xc8, 0xd4, 0xa6, 0x0e, 0xdc, 0x03,
	0x7b, 0x11, 0xc4, 0xf3, 0x2c, 0x98, 0xe7, 0x5d, 0x58, 0xdc, 0xd1, 0x13, 0xb0, 0x43, 0x12, 0x84,
	0x8b, 0x28, 0x26, 0x0a, 0xfa, 0x3d, 0x5f, 0xbe, 0xf1, 0x7e, 0xfe, 0xc6, 0xfb, 0x67, 0xf9, 0x1b,
	0x8f, 0x0b, 0x59, 0x31, 0xfc, 0xb3, 0x94, 0x4e, 0x03, 0x39, 0x7a, 0x44, 0x66, 0x6c, 0xec, 0x70,
	0x9a, 0x9a, 0x46, 0xfc, 0x8d, 0xa6, 0x49, 0xde, 0xbb, 0x3d, 0x2c, 0x2f, 0xe8, 0x00, 0xdc, 0x88,
	0xa9, 0xe2, 0x58, 0x04, 0x17, 0x22, 0x27, 0x36, 0x86, 0x88, 0x89, 0x9c, 0x9d, 0x04, 0x17, 0xe8,
	0x21, 0x00, 0xcb, 0x2e, 0x96, 0x11, 0x63, 0x11, 0x8d, 0x45, 0xe7, 0x72, 0xb0, 0x4e, 0x0b, 0x12,
	0x36, 0xd8, 0x1c, 0xe9, 0x91, 0xd1, 0x61, 0xa5, 0x86, 0xb4, 0xb6, 0x37, 0xa4, 0xf7, 0x87, 0x3a,
	0x80, 0x36, 0x5c, 0x41, 0xfa, 0x3e, 0xf4, 0xb4, 0xb4, 0x46, 0xdb, 0xd5, 0xc4, 0xc9, 0xd8, 0x7c,
	0xe3, 0x1a, 0xe6, 0x1b, 0xb7, 0xad, 0xd8, 0x6f, 0x41, 0x8b, 0xcd, 0x68, 0x42, 0xd4, 0x00, 0x94,
	0x17, 0xfe, 0x39, 0x71, 0x98, 0xd2, 0x0b, 0x5e, 0x63, 0x4c, 0xcd, 0x42, 0x57, 0x10, 0x7f, 0x29,
	0x69, 0x7c, 0xc7, 0xb9, 0xc8, 0xa2, 0x45, 0x38, 0x8d, 0xe2, 0x4b, 0xaa, 0xc6, 0x62, 0x57, 0x50,
	0x26, 0xf1, 0x25, 0x45, 0xfb, 0xe0, 0xcc, 0xe8, 0x72, 0x19, 0xa5, 0xd3, 0xab, 0x80, 0x5d, 0x09,
	0x74, 0xbb, 0x18, 0x24, 0xe9, 0xb3, 0x80, 0x5d, 0xf1, 0x62, 0x50, 0x39, 0x93, 0x53, 0xd1, 0xc6,
	0xc5, 0x9d, 0x83, 0xa9, 0xd1, 0x10, 0x60, 0x6a, 0xa4, 0x35, 0x98, 0x46, 0x26, 0x4c, 0xbe, 0xf7,
	0xb7, 0x3a, 0x00, 0x26, 0x2b, 0xca, 0x22, 0x3e, 0x80, 0x2b, 0x60, 0x96, 0x27, 0x76, 0xbd, 0x3a,
	0xb1, 0xef, 0x43, 0x2f, 0x29, 0x0c, 0x68, 0x40, 0x5d, 0x4d, 0x5c, 0xc7, 0xbb, 0x79, 0x23, 0xde,
	0xad, 0xf2, 0x70, 0xb1, 0x3f, 0x3b, 0xfb, 0xf2, 0xc4, 0x58, 0x0b, 0x3b, 0xfc, 0xce, 0x97, 0xc2,
	0x9f, 0xf0, 0x95, 0x68, 0x45, 0xa7, 0xe9, 0xf5, 0x8a, 0x08, 0x38, 0x77, 0x8e, 0x6e, 0xf9, 0x3a,
	0x0c, 0x71, 0x3c, 0xbb, 0x5e, 0x11, 0xbe, 0xf8, 0xc8, 0x93, 0xf7, 0x25, 0x9f, 0x02, 0xf2, 0x8c,
	0x6c, 0xb9, 0xee, 0xf6, 0x6b, 0x68, 0xc7, 0x6c, 0xda, 0xbe, 0x85, 0xba, 0xd0, 0x3a, 0x23, 0x2c,
	0x65, 0xfd, 0x3a, 0x1f, 0x1b, 0xa7, 0x74, 0x91, 0xa5, 0x11, 0x8d, 0xfb, 0x0d, 0x2e, 0x28, 0xe7,
	0x17, 0x4f, 0x58, 0xbf, 0xe9, 0xfd, 0x1c, 0xdc, 0xe2, 0x7b, 0x7c, 0xd1, 0x7c, 0x0c, 0x3a, 0xe0,
	0x88, 0x68, 0xdc, 0xb5, 0x53, 0x78, 0x4d, 0xc0, 0x3b, 0x86, 0xee, 0x38, 0x47, 0xb1, 0x02, 0x3b,
	0x82, 0xe6, 0x2a, 0x48, 0xaf, 0xe4, 0x3e, 0x85, 0xc5, 0x19, 0xdd, 0x86, 0xb6, 0xdc, 0x8a, 0xd5,
	0x98, 0x50, 0x37, 0xef, 0x67, 0xe0, 0xe4, 0x86, 0xb8, 0x23, 0xef, 0x43, 0x91, 0x1d, 0xed, 0x07,
	0xf8, 0xc5, 0xb7, 0xb0, 0xc9, 0xf6, 0xfe, 0x68, 0x41, 0x0f, 0x93, 0x19, 0x4d, 0x42, 0x4c, 0xbe,
	0xce, 0x08, 0xab, 0x0e, 0xae, 0x23, 0xb0, 0xe5, 0x88, 0x25, 0x6c, 0x50, 0x3f, 0x68, 0x6c, 0x7b,
	0x90, 0x73, 0x39, 0xf4, 0x11, 0xec, 0xc8, 0xa4, 0x16, 0x9a, 0x0d, 0xa1, 0xb9, 0x69, 0x0f, 0xeb,
	0xcd, 0xf5, 0x85, 0x30, 0xef, 0x9f, 0x16, 0xf4, 0x46, 0x33, 0x0e, 0xfa, 0x4d, 0x0e, 0x19, 0xa5,
	0x54, 0xbf, 0xb1, 0x94, 0x1a, 0xeb, 0xa5, 0xb4, 0x36, 0x7d, 0x9b, 0xa5, 0xe9, 0xab, 0x9f, 0x9a,
	0xd6, 0xeb, 0x3c, 0x35, 0xe8, 0x43, 0x70, 0xcd, 0xe8, 0x44, 0x6d, 0x6e, 0x8e, 0xcd, 0x31, 0x62,
	0xf3, 0xbe, 0x80, 0xbe, 0x4e, 0x82, 0x8a, 0xcd, 0x5c, 0x96, 0xac, 0xd2, 0xb2, 0xb4, 0xed, 0xc5,
	0xf0, 0xfe, 0x61, 0xc1, 0xae, 0x51, 0x5a, 0x37, 0x40, 0x75, 0x08, 0x4d, 0xd1, 0x21, 0xf5, 0x2d,
	0x1d, 0x22, 0x24, 0x2a, 0x7d, 0xde, 0x78, 0x8d, 0x3e, 0x6f, 0x6e, 0xef, 0xf3, 0xb5, 0xff, 0x0e,
	0xeb, 0xd1, 0xb4, 0x4b, 0xd1, 0xbc, 0x07, 0xdd, 0xaf, 0x54, 0xd8, 0x0c, 0xdd, 0x85, 0x6e, 0x8e,
	0x81, 0x2c, 0xdf, 0x2e, 0xd6, 0x04, 0x6f, 0x1f, 0x9c, 0x73, 0x7c, 0x82, 0x09, 0x5b, 0xd1, 0x98,
	0x11, 0xbe, 0x7f, 0xf2, 0xf1, 0x20, 0xb1, 0xe3, 0x47, 0xaf, 0x0d, 0xcd, 0x5f, 0xd1, 0x28, 0x3c,
	0xfa, 0x0b, 0xc0, 0xee, 0x28, 0x4b, 0xe9, 0x3c, 0x09, 0x42, 0x92, 0x9c, 0x92, 0xe4, 0x79, 0x34,
	0x23, 0xe8, 0x1d, 0xe8, 0x1c, 0x93, 0xf4, 0x94, 0x2c, 0x2e, 0x51, 0xcb, 0xe7, 0x72, 0x7b, 0x72,
	0x69, 0xf1, 0x6a, 0xc8, 0x13, 0x2c, 0xf9, 0x37, 0xd8, 0x5f, 0xeb, 0x09, 0x2d, 0x73, 0x07, 0x6c,
	0x25, 0xc3, 0x72, 0xfd, 0xb6, 0xe0, 0x31, 0xaf, 0x86, 0xee, 0x02, 0x9c, 0xaf, 0xc2, 0x20, 0x25,
	0xc2, 0x86, 0xd4, 0xd1, 0xaa, 0xef, 0x0a, 0x55, 0xf5, 0xf7, 0xa9, 0x64, 0x5f, 0xed, 0x3e, 0x5e,
	0x0d, 0x7d, 0x00, 0x6f, 0xe7, 0x52, 0x4f, 0xaf, 0xb9, 0xe6, 0x28, 0x0e, 0xf3, 0x15, 0xdf, 0x5f,
	0xeb, 0x0b, 0x43, 0xe9, 0x47, 0xd0, 0xcd, 0x95, 0x58, 0xc5, 0x76, 0x47, 0x8a, 0x71, 0x07, 0xf7,
	0xc1, 0x11, 0x5b, 0x3f, 0x91, 0x5e, 0x28, 0x03, 0x86, 0xa1, 0x21, 0x38, 0x32, 0x82, 0x75, 0x01,
	0x19, 0xa9, 0x88, 0x61, 0xd7, 0xe0, 0xab, 0x5d, 0xab, 0x22, 0x35, 0x04, 0x47, 0xfe, 0x9b, 0xb9,
	0xc1, 0x8a, 0x74, 0xb7, 0x88, 0xaa, 0xec, 0xae, 0x64, 0x08, 0x77, 0xa1, 0x90, 0x2b, 0xe0, 0xb6,
	0x15, 0x9f, 0xc7, 0xf3, 0x04, 0x06, 0x5a, 0xe0, 0xd7, 0x51, 0x7a, 0x65, 0x2e, 0xd6, 0x25, 0xbb,
	0xa6, 0xde, 0x47, 0x02, 0x64, 0x3d, 0xce, 0x93, 0x65, 0xc0, 0x81, 0xe5, 0x0f, 0x4b, 0x59, 0xcd,
	0xf5, 0x8d, 0x6a, 0x13, 0x45, 0xe2, 0x4a, 0x08, 0x95, 0xfb, 0xb9, 0xbb, 0xa6, 0xdf, 0x07, 0xe0,
	0x4a, 0x94, 0xca, 0x32, 0x05, 0x02, 0x8f, 0xf9, 0xd0, 0xbd, 0x4c, 0x08, 0xbb, 0xba, 0x01, 0x05,
	0xd7, 0x58, 0x7e, 0xb8, 0xc7, 0x3f, 0x85, 0xdb, 0xc7, 0x24, 0x35, 0xb6, 0xd3, 0xa7, 0xd7, 0x37,
	0x6a, 0x1a, 0x52, 0x5e, 0x0d, 0x3d, 0x84, 0xbe, 0x74, 0x78, 0x0d, 0x9b, 0xf5, 0x4a, 0x2a, 0xfc,
	0x7a, 0x08, 0x7d, 0xe9, 0xf9, 0xeb, 0x08, 0xff, 0x18, 0x76, 0x78, 0x2b, 0x19, 0xab, 0x47, 0x59,
	0xd4, 0x35, 0xb6, 0x0e, 0xee, 0x8b, 0x0f, 0xbd, 0x35, 0x8d, 0x8a, 0xf3, 0xe6, 0x9a, 0xe2, 0xd5,
	0xd0, 0x87, 0xf0, 0x83, 0xbc, 0xae, 0xdf, 0xe4, 0x33, 0x45, 0x14, 0x5b, 0xbe, 0x54, 0x8a, 0xc2,
	0xdc, 0x46, 0x5f, 0x95, 0x8b, 0x27, 0xd0, 0x3f, 0x26, 0xa9, 0x1e, 0xa5, 0xbc, 0x6c, 0x90, 0x5f,
	0x19, 0xc6, 0x95, 0xd2, 0xb9, 0x0f, 0xee, 0x31, 0x49, 0xf5, 0x9c, 0x53, 0x05, 0x0d, 0x7e, 0x41,
	0x12, 0xfd, 0xcf, 0xdd, 0x31, 0xdf, 0xf3, 0x5d, 0xbf, 0xfc, 0x6a, 0xec, 0xb9, 0xbe, 0x21, 0xe0,
	0xd5, 0xd0, 0x91, 0xc0, 0xd5, 0xd8, 0xe2, 0x36, 0xb9, 0x63, 0xae, 0x22, 0x5e, 0xed, 0xe9, 0xe0,
	0xef, 0x2f, 0x86, 0xd6, 0xb7, 0x2f, 0x86, 0xd6, 0xbf, 0x5f, 0x0c, 0xad, 0x3f, 0xbd, 0x1c, 0xd6,
	0xbe, 0x7d, 0x39, 0xac, 0xfd, 0xeb, 0xe5, 0xb0, 0x76, 0xd1, 0x16, 0x7f, 0x21, 0x3e, 0xf8, 0x6f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x9d, 0x7c, 0xee, 0x0f, 0x6f, 0x14, 0x00, 0x00,
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.IsAdmin {
		dAtA[i] = 0x10
		i++
		if m.IsAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Student_ID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Student_ID)))
		i += copy(dAtA[i:], m.Student_ID)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Avatar_URL) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Avatar_URL)))
		i += copy(dAtA[i:], m.Avatar_URL)
	}
	if len(m.RemoteIdentities) > 0 {
		for _, msg := range m.RemoteIdentities {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x42
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Users) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Users) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RemoteIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteIdentity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.Remote_ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Remote_ID))
	}
	if len(m.AccessToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.AccessToken)))
		i += copy(dAtA[i:], m.AccessToken)
	}
	if m.User_ID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User_ID))
	}
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Course_ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course_ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x32
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Groups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Groups) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Course) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Course) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.CourseCreator_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.CourseCreator_ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.Year != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Year))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Provider) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.Directory_ID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Directory_ID))
	}
	if m.Enrolled != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Enrolled))
	}
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0x52
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0x62
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Courses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Courses) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Courses) > 0 {
		for _, msg := range m.Courses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Enrollment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Enrollment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.Course_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course_ID))
	}
	if m.User_ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Group_ID))
	}
	if m.User != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User.Size()))
		n1, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Course != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course.Size()))
		n2, err := m.Course.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Group != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Group.Size()))
		n3, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Status != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *Enrollments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Enrollments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Enrollments) > 0 {
		for _, msg := range m.Enrollments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Assignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Assignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.Course_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course_ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if m.Deadline != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Deadline.Size()))
		n4, err := m.Deadline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.AutoApprove {
		dAtA[i] = 0x30
		i++
		if m.AutoApprove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Order != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Order))
	}
	if m.IsGroupLab {
		dAtA[i] = 0x40
		i++
		if m.IsGroupLab {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Submission != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Submission.Size()))
		n5, err := m.Submission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Assignments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Assignments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Submission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Submission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.Assignment_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Assignment_ID))
	}
	if m.User_ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Group_ID))
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Score))
	}
	if len(m.ScoreObjects) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.ScoreObjects)))
		i += copy(dAtA[i:], m.ScoreObjects)
	}
	if len(m.BuildInfo) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.BuildInfo)))
		i += copy(dAtA[i:], m.BuildInfo)
	}
	if len(m.CommitHash) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.CommitHash)))
		i += copy(dAtA[i:], m.CommitHash)
	}
	if m.Approved {
		dAtA[i] = 0x48
		i++
		if m.Approved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Submissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Submissions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Submissions) > 0 {
		for _, msg := range m.Submissions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Repository) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repository) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.Directory_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Directory_ID))
	}
	if m.Repository_ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Repository_ID))
	}
	if m.User_ID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Group_ID))
	}
	if len(m.HTML_URL) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.HTML_URL)))
		i += copy(dAtA[i:], m.HTML_URL)
	}
	if m.RepoType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.RepoType))
	}
	return i, nil
}

func (m *Repositories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repositories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repositories) > 0 {
		for _, msg := range m.Repositories {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Directory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Directory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	return i, nil
}

func (m *Directories) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Directories) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Directories) > 0 {
		for _, msg := range m.Directories {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if len(m.Statuses) > 0 {
		dAtA7 := make([]byte, len(m.Statuses)*10)
		var j6 int
		for _, num := range m.Statuses {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAg(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.GroupStatuses) > 0 {
		dAtA9 := make([]byte, len(m.GroupStatuses)*10)
		var j8 int
		for _, num := range m.GroupStatuses {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAg(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	return i, nil
}

func (m *ActionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.User_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Group_ID))
	}
	if m.Course_ID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course_ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Status))
	}
	if m.GroupStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.GroupStatus))
	}
	return i, nil
}

func (m *DirectoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.Course_ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course_ID))
	}
	return i, nil
}

func (m *RepositoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepositoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.ID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Type))
	}
	if m.Directory_ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Directory_ID))
	}
	if m.Repository_ID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Repository_ID))
	}
	if m.User_ID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.User_ID))
	}
	if m.Course_ID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAg(dAtA, i, uint64(m.Course_ID))
	}
	return i, nil
}

func (m *Providers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Providers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, s := range m.Providers {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *URLResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAg(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	return i, nil
}

func (m *Void) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintAg(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.IsAdmin {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Student_ID)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Avatar_URL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if len(m.RemoteIdentities) > 0 {
		for _, e := range m.RemoteIdentities {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Users) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *RemoteIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Remote_ID != 0 {
		n += 1 + sovAg(uint64(m.Remote_ID))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.User_ID != 0 {
		n += 1 + sovAg(uint64(m.User_ID))
	}
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Course_ID != 0 {
		n += 1 + sovAg(uint64(m.Course_ID))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Groups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Course) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.CourseCreator_ID != 0 {
		n += 1 + sovAg(uint64(m.CourseCreator_ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Year != 0 {
		n += 1 + sovAg(uint64(m.Year))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Directory_ID != 0 {
		n += 1 + sovAg(uint64(m.Directory_ID))
	}
	if m.Enrolled != 0 {
		n += 1 + sovAg(uint64(m.Enrolled))
	}
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Courses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Courses) > 0 {
		for _, e := range m.Courses {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Enrollment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.Course_ID != 0 {
		n += 1 + sovAg(uint64(m.Course_ID))
	}
	if m.User_ID != 0 {
		n += 1 + sovAg(uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		n += 1 + sovAg(uint64(m.Group_ID))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Course != nil {
		l = m.Course.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	return n
}

func (m *Enrollments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Enrollments) > 0 {
		for _, e := range m.Enrollments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Assignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.Course_ID != 0 {
		n += 1 + sovAg(uint64(m.Course_ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Deadline != nil {
		l = m.Deadline.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	if m.AutoApprove {
		n += 2
	}
	if m.Order != 0 {
		n += 1 + sovAg(uint64(m.Order))
	}
	if m.IsGroupLab {
		n += 2
	}
	if m.Submission != nil {
		l = m.Submission.Size()
		n += 1 + l + sovAg(uint64(l))
	}
	return n
}

func (m *Assignments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Submission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.Assignment_ID != 0 {
		n += 1 + sovAg(uint64(m.Assignment_ID))
	}
	if m.User_ID != 0 {
		n += 1 + sovAg(uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		n += 1 + sovAg(uint64(m.Group_ID))
	}
	if m.Score != 0 {
		n += 1 + sovAg(uint64(m.Score))
	}
	l = len(m.ScoreObjects)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.BuildInfo)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.CommitHash)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Approved {
		n += 2
	}
	return n
}

func (m *Submissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Submissions) > 0 {
		for _, e := range m.Submissions {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Repository) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.Directory_ID != 0 {
		n += 1 + sovAg(uint64(m.Directory_ID))
	}
	if m.Repository_ID != 0 {
		n += 1 + sovAg(uint64(m.Repository_ID))
	}
	if m.User_ID != 0 {
		n += 1 + sovAg(uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		n += 1 + sovAg(uint64(m.Group_ID))
	}
	l = len(m.HTML_URL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.RepoType != 0 {
		n += 1 + sovAg(uint64(m.RepoType))
	}
	return n
}

func (m *Repositories) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Repositories) > 0 {
		for _, e := range m.Repositories {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *Directory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	return n
}

func (m *Directories) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Directories) > 0 {
		for _, e := range m.Directories {
			l = e.Size()
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *RecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if len(m.Statuses) > 0 {
		l = 0
		for _, e := range m.Statuses {
			l += sovAg(uint64(e))
		}
		n += 1 + sovAg(uint64(l)) + l
	}
	if len(m.GroupStatuses) > 0 {
		l = 0
		for _, e := range m.GroupStatuses {
			l += sovAg(uint64(e))
		}
		n += 1 + sovAg(uint64(l)) + l
	}
	return n
}

func (m *ActionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.User_ID != 0 {
		n += 1 + sovAg(uint64(m.User_ID))
	}
	if m.Group_ID != 0 {
		n += 1 + sovAg(uint64(m.Group_ID))
	}
	if m.Course_ID != 0 {
		n += 1 + sovAg(uint64(m.Course_ID))
	}
	if m.Status != 0 {
		n += 1 + sovAg(uint64(m.Status))
	}
	if m.GroupStatus != 0 {
		n += 1 + sovAg(uint64(m.GroupStatus))
	}
	return n
}

func (m *DirectoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	if m.Course_ID != 0 {
		n += 1 + sovAg(uint64(m.Course_ID))
	}
	return n
}

func (m *RepositoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAg(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovAg(uint64(m.Type))
	}
	if m.Directory_ID != 0 {
		n += 1 + sovAg(uint64(m.Directory_ID))
	}
	if m.Repository_ID != 0 {
		n += 1 + sovAg(uint64(m.Repository_ID))
	}
	if m.User_ID != 0 {
		n += 1 + sovAg(uint64(m.User_ID))
	}
	if m.Course_ID != 0 {
		n += 1 + sovAg(uint64(m.Course_ID))
	}
	return n
}

func (m *Providers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, s := range m.Providers {
			l = len(s)
			n += 1 + l + sovAg(uint64(l))
		}
	}
	return n
}

func (m *URLResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovAg(uint64(l))
	}
	return n
}

func (m *Void) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovAg(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAg(x uint64) (n int) {
	return sovAg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdmin = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Student_ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Student_ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar_URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar_URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIdentities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteIdentities = append(m.RemoteIdentities, &RemoteIdentity{})
			if err := m.RemoteIdentities[len(m.RemoteIdentities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Users) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Users: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Users: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote_ID", wireType)
			}
			m.Remote_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Remote_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User_ID", wireType)
			}
			m.User_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course_ID", wireType)
			}
			m.Course_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Course_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Group_GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Groups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Groups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Groups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Course) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Course: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Course: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseCreator_ID", wireType)
			}
			m.CourseCreator_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CourseCreator_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			m.Year = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Year |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directory_ID", wireType)
			}
			m.Directory_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Directory_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrolled", wireType)
			}
			m.Enrolled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enrolled |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &Assignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Courses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Courses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Courses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Courses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Courses = append(m.Courses, &Course{})
			if err := m.Courses[len(m.Courses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Enrollment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enrollment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enrollment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course_ID", wireType)
			}
			m.Course_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Course_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User_ID", wireType)
			}
			m.User_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group_ID", wireType)
			}
			m.Group_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Course == nil {
				m.Course = &Course{}
			}
			if err := m.Course.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Enrollments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enrollments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enrollments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enrollments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enrollments = append(m.Enrollments, &Enrollment{})
			if err := m.Enrollments[len(m.Enrollments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course_ID", wireType)
			}
			m.Course_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Course_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deadline == nil {
				m.Deadline = &types.Timestamp{}
			}
			if err := m.Deadline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApprove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApprove = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGroupLab", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGroupLab = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Submission == nil {
				m.Submission = &Submission{}
			}
			if err := m.Submission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assignments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assignments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assignments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &Assignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Submission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignment_ID", wireType)
			}
			m.Assignment_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Assignment_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User_ID", wireType)
			}
			m.User_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group_ID", wireType)
			}
			m.Group_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreObjects", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScoreObjects = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Approved = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Submissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Submissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Submissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submissions = append(m.Submissions, &Submission{})
			if err := m.Submissions[len(m.Submissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repository) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repository: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repository: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directory_ID", wireType)
			}
			m.Directory_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Directory_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repository_ID", wireType)
			}
			m.Repository_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Repository_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User_ID", wireType)
			}
			m.User_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group_ID", wireType)
			}
			m.Group_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTML_URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTML_URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoType", wireType)
			}
			m.RepoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepoType |= Repository_RepoType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repositories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repositories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repositories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repositories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repositories = append(m.Repositories, &Repository{})
			if err := m.Repositories[len(m.Repositories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Directory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Directory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Directory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Directories) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Directories: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Directories: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Directories = append(m.Directories, &Directory{})
			if err := m.Directories[len(m.Directories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v Enrollment_UserStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Enrollment_UserStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Statuses = append(m.Statuses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Statuses) == 0 {
					m.Statuses = make([]Enrollment_UserStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Enrollment_UserStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Enrollment_UserStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Statuses = append(m.Statuses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
		case 3:
			if wireType == 0 {
				var v Group_GroupStatus
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Group_GroupStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupStatuses = append(m.GroupStatuses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GroupStatuses) == 0 {
					m.GroupStatuses = make([]Group_GroupStatus, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Group_GroupStatus
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Group_GroupStatus(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupStatuses = append(m.GroupStatuses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupStatuses", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User_ID", wireType)
			}
			m.User_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group_ID", wireType)
			}
			m.Group_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course_ID", wireType)
			}
			m.Course_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Course_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Enrollment_UserStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupStatus", wireType)
			}
			m.GroupStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupStatus |= Group_GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course_ID", wireType)
			}
			m.Course_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Course_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepositoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepositoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepositoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Repository_RepoType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Directory_ID", wireType)
			}
			m.Directory_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Directory_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repository_ID", wireType)
			}
			m.Repository_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Repository_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User_ID", wireType)
			}
			m.User_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Course_ID", wireType)
			}
			m.Course_ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Course_ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Providers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Providers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Providers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Void) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAg
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAg
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAg
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAg(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAg
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAg = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAg   = fmt.Errorf("proto: integer overflow")
)
